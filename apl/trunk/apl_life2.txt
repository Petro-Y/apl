Повернемось до нашої гри. 
[b]Решта прикладу з Вікіпедії.[/b] Основна частина його така ж, як і в мене, з тією відмінністю, що замість двох редукцій-додавання було застосовано вирівнювання (унарна кома — тобто, перетворення багатовимірного масиву в одновимірний), і після цього редукцію-додавання. Результат буде той же: загорнута в контейнер матриця, кожен елемент якої дорівнюватиме сумі відповідної клітинки та її сусідів у початковій матриці.

Далі, якщо я виразив результат підрахунку в вигляді десяткового числа, де розряд десятків відображає поточну клітинку, а розряд одиниць — суму сусідніх, то тут логіку гри розгорнули трохи інакше. Клітинка нового покоління стає заповненою у трьох випадках: поруч із нею три сусіди й вона порожня, поруч із нею два сусіди й вона заповнена, поруч із нею три сусіди й вона заповнена. Іншими словами, у квадраті навколо поточної клітинки є три заповнені (і поточна клітинка необов'язково заповнена), або в цьому квадраті 4 заповнені клітинки і поточна обов'язково заповнена. Для окремої клітинки це спрощено можна записати як (s=3)∨((c=1)∧(s=4)),  де c — значення поточної клітинки, s — сума її та сусідніх клітинок. ∨ та ∧ — логічні АБО та І. В APL нема булевого типу, замість true та false використовуються 1 та 0, тому це ж можна записати й так: (s=3)∨(c ∧ s=4). Або так: (1 ∧ s=3)∨(c ∧ s=4) — одиниця тут ні на що не вплине, далі стане зрозуміло, для чого вона тут.

[code]{3 4=+/,¯1 0 1∘.⊖¯1 0 1∘.⌽⊂⍵}[/code] — результатом такої функції буде масив з двох загорнутих матриць, у кожній з яких одиниці стоятимуть там, де s дорівнює 3 та 4 відповідно (назвімо їх s3 та s4).

Наступний крок — зв'язати ці дві матриці з початковою. Вище я показував, як працює ∘. (зовнішній добуток). Крапка без кружечка є оператором внутрішнього добутку (який я пізніше розгляну окремо) — поки що достатньо знати, що 1 ⍵∨.∧s3 s4 можна записати як (1∧s3)∨(⍵∧s4), що дуже нагадує формулу для окремої клітинки, яку я вивів вище. Результатом буде загорнута матриця з готовим результатом, яку лишається вийняти з контейнера унарною стрілккою ↑ чи ⊃ (у даному випадку, нема різниці): 
[code]life←{↑1 ⍵∨.∧3 4=+/,¯1 0 1∘.⊖¯1 0 1∘.⌽⊂⍵}[/code]

[b]Подальше вдосконалення.[/b] (Код нижче працює в NGN APL і для інших діалектів може потребувати змін).
Недолік обох реалізацій — те, що гра відбувається на обмеженому тороїдальному полі, тоді як класичні правила розраховані на необмежену площу. Тому перед кожним ходом слід зробити так, щоб ігрове поле було обрамлене нулями. 

Бінарні ↑ (взяти) та ↓ (відкинути) — функції, що дозволяють змінювати розмір масиву. Якщо вказано додатнє число, функція залишить/відкине відповідну кількість елементів на початку масиву, якщо від'ємне — вкінці. Якщо розмір вибірки більший за розмір масиву, ↑ бере всі елементи масиву, а решту заповнює нулями. Таким чином, щоб дописати нуль на початок масиву A, треба знайти його розмірність, збільшити на одиницю, змінити знак на протилежний і взяти цю кількість елементів: (- 1+⍴A)↑A. Щоб вставити рядок нулів на початок двовимірного масиву: (- 1 0+⍴A)↑A
Сторін усього чотири, тому матрицю слід розширити на один рядок, повернути на 90° (для чого її транспонуємо (⍉) й відображаємо по горизонталі чи вертикалі (⌽ або ⊖)), повторити всю попередню послідовність дій чотири рази (для чого модифікуємо функцію оператором ⍣):
[code]zborder←{⍉⊖(-1 0+⍴⍵)↑⍵}⍣4[/code]
Якщо перед кожним ходом обгортати поле нулями по всьому периметру, це призведе до перевитрат площі, тому ми будемо розширювати поле лише там, де на краю з'явились одинички.

Перевірку умови можна зробити, знайшовши максимальний елемент у першому рядку (якщо там є одиниці, результатом буде 1, інакше 0): [code]{⌈/0⌷⍵}[/code]
Стиснутий квадрат ⌷ (не плутати з ⎕) є альтернативною формою запису індексу масива, ⍵[0] чи 0⌷⍵ дають однаковий результат — перший рядок масиву (результати відрізнятимуться, якщо в ролі індексу використовується масив, але, в даному випадку, це скаляр). ⌈ (максимум) і вже знайома нам редукція (/) разом дають пошук найбільшого елемента в масиві (чи, в даному випадку, в першому рядку).

Складний момент — зробити вибір за цією умовою. На початку історії мови, коли goto ще вважалося мейнстрімом, вибір здійснювався як умовний перехід на мітку. Згодом, коли колективна свідомість кодерів вирішила, що goto то є гріх великий, APL збагатився алгоритмічними конструкціями :if...:else...:endif. Проте, і перше, і друге можливе лише в тілі «класичних» функцій, яких у початково обраному мною діалекті нема — лише лямбди з розширеними можливостями (які, знову ж, є пізнішим нововведенням — у старих діалектах були лише «класичні» функції, лямбди з'явилися пізніше, конструкція вибору в них — ще пізніше доповнення, не скрізь реалізоване). З цієї точки зору, код бажано писати так, щоб уникнути галуження взагалі. Поки що ж zborder з перевіркою умови виглядатиме так:
[code]zborder← ({⍉⊖{⌈/0⌷⍵:(-1 0+⍴⍵)↑⍵⋄⍵}⍵}⍣4)[/code]
Символ ⋄ виконує роль роздільника інструкцій (тобто, є замінником переходу на новий рядок). Конструкція УМОВА:ЗНАЧЕННЯ працює як if(УМОВА)return ЗНАЧЕННЯ. Усю конструкцію з вибором я виніс у вкладену функцію, лишивши поворот матриці за її межами.

Аналогічним чином можна зрізати порожні краї. Фігури часом розростаються до чималих розмірів, тому має сенс поєднувати обрізання та розширення поля. Так, це зробить зміщення фігур (таких як «планер») менш наглядним — щоб краще побачити, як вони рухаються, можна додатково розмістити на полі якусь стабільну фігуру, відносно якої простіше відстежувати переміщення. 
[code]zborder←({⍉⊖{⌈/0⌷⍵:(-1 0+⍴⍵)↑⍵⋄⍵}{⌈/0⌷⍵:⍵⋄1↓⍵}⍵}⍣4)
inflife←mylife zborder[/code]

Для кількох ходів...

[b]Оформлення виводу.[/b] Видивлятися обриси фігури між нулями й одиницями доволі незручно, тому краще відображати їх у вигляді якихось символів. Це просто: беремо рядок із двох символів (це може бути щось із базового ASCII, напр., '.o', або можна взяти щось із багатого набору APL — '⋄⍞', '.≡' і т.п. Рядок вважається масивом, а тому до нього можна застосувати операцію індекса — тобто, '.o'[0]='.', '.o'[1]='o'. Якщо ж замість простого числа індексом буде масив, то на виході ми отримаємо масив такої ж розмірності, що й масив індексів, усі елементи якого буде замінено елементами лівого масиву (чи, в нашрму випадку, рядка) — таким чином, на місці нулів підставиться перший символ рядка, на місці одиниць — другий. 

[b]Як вводити фігури.[/b] По-перше, можна просто набрати їх нулями й одиницями, а далі перетворити одновимірну cnhernehe на двовимірну з допомогою ⍴
[code]map←4 4⍴0 1 1 0, 1 0 1 0, 0 1 0 1, 0 1 1 0[/code]
(кома (оператор конкатенації) використана лише для наглядності й тут необов'язкова — вона лише об'єднує декілька одновимірних масивів в один, перетворення ж у два виміри — робота виключно ⍴).
Приблизно те ж саме, але краще: двовимірний масив можна задати як одновимірний масив вкладених масивів чисел, а потім розгорнути його оператором ⊃:
[code]      map←⊃(1 1)(0 1 1)(1 1)
      map
┏━━━━━┓
┃1 1 0┃
┃0 1 1┃
┃1 1 0┃
┗━━━━━┛
[/code]
(Як ви можете бачити, різна довжина масивів не є перешкодою: ті, що коротші, доповнюються нулями до довжини найдовшого).

Варіант для ледачих: фігуру можна згенерувати випадково.
[code]      map←?3 3⍴2 ⋄ map
┏━━━━━┓
┃0 1 0┃
┃1 0 0┃
┃1 1 0┃
┗━━━━━┛
[/code]

Якщо ж ми хочемо написати програму, здатну взаємодіяти з користувачем, не посвяченим у таїнство APL, краще зробити функцію, що перетворюватиме текст на матрицю нулів і одиниць. (Розгляну це наступного разу).


[b]Діалекти.[/b] Один із цікавих і неприємних (коли як) моментів. Приклад вище було написано в NGN APL (доволі мінімалістична реалізація на основі JS, дозволяє працювати онлайн у браузері чи локально з NodeJS), згодом спробував GNU APL (більше можливостей мови, але й більше мороки з її встановленням). Обидва проекти опенсорсні. Найбільш мейнстрімним у наш час вважається пропрієтарний Dyalog APL (з яким я поки що справи не мав — лише читав мануали). Також спробував NARS2000 — реалізація з рядом додаткових можливостей мови, але без можливості інтегрувати код у що-небудь (чи навіть зробити з її коду самостійний скрипт — передбачено лише інтерактивне GUI-середовище) — з моєї точки зору, мінус (утім, код проекту відкритий — якщо спробувати поритися в ньому...).

Звичайно ж, написаний вище zborder у GNU APL не запрацював.
По-перше, лямбди у GNU APL (хоча й мають деякі інші додаткові можливості) не можуть містити декілька інструкцій одночасно, як і не підтримують конструкцій УМОВА:ЗНАЧЕННЯ — зате відкривається можливість користуватися справжніми функціями, де є більше можливостей для побудови алгоритму.

По-друге, нумерація елементів масивів починається з 0 в NGN APL та з 1 у GNU APL (що, втім, можна виправити, вписавши нуль в ⎕IO — системну змінну, якою задається мінімальний індекс масивів, також вона впливає на результат унарних ⍳ та ?. Утім, мабуть, краще переписати початковий приклад так, щоб він враховував поточне значення ⎕IO — беручи до уваги, що не всі реалізації дозволяють його змінювати — зокрема, той же NGN має фіксований нульовий ⎕IO, хоча в більшості реалізацій прийнято починати відлік з одиниці).


